---
title: "[객체지향설계와패턴]Pattern 정리"
date: 2019-04-20 15:05:28 -0400
categories: jekyll update
---

1. 어댑터 패턴
    * 1-1. 클래스 어댑터(상속)
        장점: 어댑터(Adapter)를 전체를 다시 구현할 필요가 없다.(빠르다)
        단점: 상속(Generalzation)을 활용하기때문에 유연하지 못하다.
        주의: 클래스 어댑터에서는 다중상속을 이용하기 때문에 자바에서는 쓸 수 없습니다.
            쓸수있습니다.(간접적 다중상속 지원)
    * 1-2. 객체 어댑터(위임)
        장점: 구성(Composition)을 사용하기 때문에 더 뛰어나다.(유연하다)
        단점: 어댑터(Adapter)클래스의 대부분의 코드를 구현해야하기때문에 효율적이지 못하다
        
2. 퍼싸드 패턴


    * Adapter 패턴 : 한 인터페이스를 다른 인터페이스로 변환 (for 호환성)
                    인터페이스를 변경해서 클라이언트에서 필요로 하는 인터페이스로 적응시키기 위한 용도.
                    어댑터는 인터페이스를 클라이언트가 원하는 인터페이스로 바꿔주는 역할을 한다.ㅍ

    * Facade 패턴 : 인터페이스를 간단하게 바꿈 (for 간편함)
                    어떤 서브시스템에 대한 간단한 인터페이스를 제공하기 위한 용도.
                    퍼사드는 클라이언트를 복잡한 서브시스템과 분리시켜주는 역할을 한다.

3. 컴포지트 패턴 : 개별 객체와 객체 집합 모두에 대하여 동일한 인터페이스를 제공하고 싶을 때
4. 브릿지 패턴 : 추상을 구현으로부터 분리하여 독립적으로 변하게 함.
                (구현이란 실제 일을 하는 로직이라고 생각하자.)


5. 싱글톤 패턴 : 
    - 클래스가 오직 하나의 인스턴스만 생성한다는 것을 보장하는 패턴으로, 보통 웹 서비스 같은 여러 서드파티에서 해당 인스턴스에 접근할 수 있는 유일한 지점을 만드는 데 사용한다. 
        다수의 서비스에서 보내는 연결 요청을 한 곳에서 쉽게 관리하고 설정할 수 있다는 장점이 있다.
    - Enum 타입으로 구현
    ``` java
    public enum SingletonEnum {
        INSTANCE;
        public void singletonMethod() {
            // 여기서 연산을 수행함
        }
    }
    ```
    - 대규모의 확장 가능한 서버 애플리케이션을 만들 때 싱글턴 객체는 종종 병목 현상의 원인이 될 수 있다.

6. 옵저버 패턴 : 데이터의 변경이 발생했을 경우, 상대 클래스나 객체에 의존하지 않으면서 데이터 변경을 통보하고자 할 때 유용하다.
                결과적으로 통보 대상 클래스나 대상 객체의 변경에도 ConcreteSubject 클래스를 수정 없이 그대로 사용할 수 있도록 한다.


7. 중재자 패턴
    * 정의: 프로그램의 상호작용을 해야 하는 개체들이 
            서로 복잡하게 관계를 맺고 있을 경우에 
                상호작용에 관련된 행동을 별도의 형식으로 정의하여 
                    중재를 맡는 개체를 두게하는 패턴
    * 효과: 복잡한 상호작용을 하기 위한 복잡한 관계를 단순화시킬 수 있습니다.

8. 프록시 패턴

9. 책임 체인 패턴

10. 플라이 웨이트 패턴
    * 몇 개의 객체에 많은 값을 공유해야 할 때 유용하다.

    * 사례
    - String 상수 풀
    - Integer.valueOf()
        주어진 매개변수의 값을 확인하고 이전에 캐시된 값이라면 새로운 사본 인스턴스를 만들지 않고, 이전에 생성해둔 인스턴스를 반환한다.
        이 캐시의 기본 범위는 -128부터 127까지다. 캐시는 static 메모리 블록에 초기화되고 JVM이 실행되면서 Integer 클래스를 처음으로 참조할 때 생성된다.
        ``` java
        static {
            for(int k=0; k<cache.length; k++)
                cache[k] = new Integer(j++);
        }

        @Test
        public void smaeIntegerInstances() {
            final Integer a = Integer.valueOf(56);
            final Integer b = Integer.valueOf(56);
            assertSame(a, b); // a, b는 동일한 인스턴스이다.
        }
        ```
    - Null 객체 패턴
        null 값을 표현하는 객체에 플라이웨이트 패터을 사용한다.
        트리의 리프들은 자식 노드를 갖지 않는다. 각 리프 노드는 필요할 때마다 Null 객체를 참조하는 단일 플라이웨이트 객체를 사용한다.

11. 빌더 패턴

12. 팩토리 메소드 패턴

13. 추상팩토리 패턴

14. 프로토타입 패턴

15. 메멘토 패턴 : 객체의 상태를 저장해두었다가 복원해야 될 경우 사용한다.
 - 오리지널 객체는 본래의 기능에 충실하고 메멘토는 상태 정보와 관리를 맡는다.
 - 상태 역할만 분리하는 것이다.

16. 템플릿 메소드 패턴 : 알고리즘을 메소드로 구현할 때, 서브클래스 알고리즘의 `일부 단계를 재정의할 수 있도록` 하여 일부 단계의 정의를 미룰 때

17. 상태 패턴 : 각각의 클래스들이 서로 다른 상태를 나타내도록 오퍼레이션을 분배할 때

18. Strategy 패턴 
    * 지정된 알고리즘의 세부 구현을 변경할 필요 없이 쉽게 교환할 수 있게 해주는 디자인 패턴이다. 실행 중이라도 구현된 알고리즘을 교환할 수 있으므로 의존성 주입에 자주 사용된다. 의존성 주입은 테스트용 코드에서 구현된 알고리즘을 교환하거나 mock 구현을 사용할 수 있게 해준다.
    * 실행하기 전까지 어떤 구현을 사용할지 결정을 미룰 수 있다는 장점이 있다.
    * 구현을 교체 가능하도록 오퍼레이션을 캡슐화
    * "프로젝트 전체에서 변경이 일어나지 않는 부분에서 변경이 일어나는 부분을 찾아서 따로 캡슐화 한다."([출처](https://niceman.tistory.com/133))

19. 커맨드 패턴
    * 의도: 커맨드를 객체로 캡슐화한다. 기능요청을 객체화하여 동적으로 기능 설정을 바꾸거나 실행된 기능들을 기록하거나 실행된 작업들을 재복구 시킬 수 있다. 또한, 기존 코드의 변경 없이 새로운 Command를 추가할 수 있다.
    * 적용범위
        - 객체에 수행되어야 할 행위를 동적으로 설정할 때
        - 작업 수행을 요청한 시점과 실제 작업이 수행되어야 할 시점을 다르게 할 필요가 있을 때
        - Undo 기능을 지원하고자 할 때
        - System의 기능 수행 정도를 기록하고 싶을 때; 각 Command 객체들이 수행될 때마다 자신의 기록을 남김
        - 기본적인 행위들을 조합하여 더욱 복잡한 행위를 실행하고자 할 때; MacroCommand 사용

20. 데코레이터 패턴
    * 의도: 동적으로 객체에 책임을 추가한다. 상속을 통한 기능의 확장은 '각 기능 조합 별로 클래스를 추가해야 한다'는 단점이 있다. 
        예를 들면, 만약 추가해야할 기능이 3개라면 기능 조합의 수 2^3 = 8개 만큼의 하위 클래스가 필요할 것이다. 
        반면 데코레이터 패턴을 사용한다면 각각의 기능에 대한 클래스 3개만 만들고, 동적으로 조합해서 사용할 수가 있다. 
        따라서 데코레이터는 기능을 확장하기 위하여 서브클래스화를 융통적으로 선택할 수 있게 한다. 
    * 역할([출처](https://gmlwjd9405.github.io/2018/07/09/decorator-pattern.html))
        - `Component`: 기본 기능의 ConcreteComponent와 추가 기능의 Decorator의 `공통 기능을 정의`한다. 클라이언트는 Component를 통해 실제 객체를 사용한다.
        - `ConcreteComponent`: `기본 기능을 구현`하는 클래스
        - `Decorator`: 많은 수가 존재하는 구체적인 `Decorator의 공통 기능`을 제공한다.
        - `ConcreteDecorator`: 기본 기능에 추가되는 `개별적인 기능`을 뜻한다. ConcreteComponent 객체에 대한 참조가 필요한데, 이는 Decorator 클래스에서 Component 클래스로의 '합성(Composition) 관계'를 통해 표현된다.
    * 사례
        - JVM 외부 소스를 읽고 저장하는 자바의 기본 입출력 클래스는 데코레이터 패턴을 확장해서 사용한다.
            InputStream, OutputStream 클래스 그리고 하위 클래스는 구현 클래스에서 정의한 방법으로 데이터를 읽고 저장하는 데 데코레이터 패턴을 사용한다.


21. 반복자 패턴
    * 의도: 자세한 표현 방법을 나타내지 않고 객체 집합의 요소들을 순차적으로 접근하게 하는데 사용된다. 반복을 객체 안에 캡슐화 함으로써, 리스트 객체와 방문하는 프로세스 사이의 결함을 줄인다.